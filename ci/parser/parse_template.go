/*
	This command is used to parse a template file using the text/template package.
	Given a list of source versions and target versions, it will render these
	versions into the places specified by the template.

	Usage:
	parse_template template.yml output.yml

	Note: This will overwrite the contents of output.yml (if the file already
	exists) with the parsed output.
*/
package main

import (
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"text/template"
)

var sourceVersions = []string{"5"}
var targetVersions = []string{"6.1.0"}

type UpgradeJob struct {
	Source, Target string
	PrimariesOnly  bool
	NoStandby      bool
	UseLinkMode    bool
}

type Data struct {
	SourceVersions, TargetVersions []string
	UpgradeJobs                    []*UpgradeJob
	LastTargetVersion              string
	PrimariesOnly                  []bool
}

var data Data

func init() {
	var upgradeJobs []*UpgradeJob
	for _, sourceVersion := range sourceVersions {
		for _, targetVersion := range targetVersions {
			upgradeJobs = append(upgradeJobs, &UpgradeJob{
				Source: sourceVersion,
				Target: targetVersion,
			})
			upgradeJobs = append(upgradeJobs, &UpgradeJob{
				Source:      sourceVersion,
				Target:      targetVersion,
				UseLinkMode: true,
			})
			upgradeJobs = append(upgradeJobs, &UpgradeJob{
				Source:        sourceVersion,
				Target:        targetVersion,
				PrimariesOnly: true,
			})
			upgradeJobs = append(upgradeJobs, &UpgradeJob{
				Source:    sourceVersion,
				Target:    targetVersion,
				NoStandby: true,
			})
		}
	}
	// Duplicate version data here in order to simplify template logic
	data = Data{
		SourceVersions:    sourceVersions,
		TargetVersions:    targetVersions,
		UpgradeJobs:       upgradeJobs,
		LastTargetVersion: targetVersions[len(targetVersions)-1],
	}
}

func main() {
	templateFilepath, pipelineFilepath := os.Args[1], os.Args[2]
	// The escapeVersion function is used to ensure that the gcs-resource concourse
	// plugin regex matches the version correctly.
	// As an example if we didn't do this, 60100 would match version 6.1.0
	templateFuncs := template.FuncMap{"escapeVersion": func(version string) string {
		return regexp.QuoteMeta(version)
	}}

	yamlTemplate, err := template.New("Pipeline Template").Funcs(templateFuncs).ParseFiles(templateFilepath)
	if err != nil {
		log.Fatalf("error parsing %s: %+v", templateFilepath, err)
	}
	// Duplicate version data here in order to simplify template logic

	templateFilename := filepath.Base(templateFilepath)
	// Create truncates the file if it already exists, and opens it for writing
	pipelineFile, err := os.Create(path.Join(pipelineFilepath))
	if err != nil {
		log.Fatalf("error opening %s: %+v", pipelineFilepath, err)
	}
	_, err = pipelineFile.WriteString("## Code generated by ci/generate.go - DO NOT EDIT\n")
	if err != nil {
		log.Fatalf("error writing %s: %+v", pipelineFilepath, err)
	}

	err = yamlTemplate.ExecuteTemplate(pipelineFile, templateFilename, data)
	closeErr := pipelineFile.Close()
	if err != nil {
		log.Fatalf("error executing template: %+v", err)
	}
	if closeErr != nil {
		log.Fatalf("error closing %s: %+v", pipelineFilepath, closeErr)
	}
}
